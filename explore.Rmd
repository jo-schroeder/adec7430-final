---
title: "Explore the Models"
output: 
  html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(
  message = FALSE, warning = FALSE, echo = FALSE
)

# explore correlation between age and nomination
# sofia actress this year

# loading packages
library(lubridate)
library(dtwclust)
library(ggthemes)
library(ggplot2)
library(plotly)
library(dplyr)
library(tidyr)
library(tsfeatures)
library(tidymodels)
library(purrr)
library(readr)
library(stringr)
library(caret)
library(randomForest)
library(tibble)

# load in data
data_dir <- "./data/"
actors <- read_csv(paste0(data_dir, "actors_features.csv"))
trends <- read_csv(paste0(data_dir, "trends.csv"))

# summary stats and missingness
summary(actors)
# Some of the actor info of interest has NA values (15 birthdays, 5 Popularity scores), so we will have to decide what we want to do about those
summary(trends)
# <1 trend needs to be recoded as numeric, I think we should choose 0 

# Exploring birth years of actors
actors %>% 
  ggplot(aes(x = birth_year, fill = nominee)) +
  geom_histogram() +
  labs(title = "Birthday of Oscar Nominated Actors",
       subtitle = "Nominated 2004-Present")

# by nominee
actors %>% 
  ggplot(aes(x = birth_year, fill = nominee)) +
  geom_histogram() +
  labs(title = "Birthday of Oscar Nominated Actors",
       subtitle = "Nominated 2004-Present")

# by gender
actors %>% 
  ggplot(aes(x = birth_year, fill = Gender)) +
  geom_histogram() +
  labs(title = "Birthday of Oscar Nominated Actors",
       subtitle = "Nominated 2004-Present")
# This is sort of interesting- there's 10 male and 10 female actors nominated every year. This suggests that men born after 1975 are less represented in nominations overall, esp. compared to women in the same age group. Dominance of older actors in male categories?

# exploring age at nomination
actors %>% 
  filter(nominee == 1) %>%
  mutate(min_year = map_dbl(nominated_years, function(s) {
    s %>%
      str_remove_all("\\[|\\]") %>%       
      str_split(",\\s*") %>%              
      unlist() %>%
      as.numeric() %>%
      min(na.rm = TRUE)
  })) %>%
  mutate(age_at_nomination = as.numeric(difftime(min_year, birth_year))) %>%
  ggplot(aes(x = age_at_nomination)) +
  geom_histogram() +
  labs(title = "Age at Nomination for Oscar Nominated Actors",
       subtitle = "Nominated 2004-Present")
# Obviously there's an error here - I'll have to go back and check the API call results for the 130 year old but I'm guessing there's another famous person with the same name
```


```{r}
# interactive trends plot
p <- plot_ly(type = "scatter", mode = "lines")

trends <- trends %>%
  mutate(across(everything(), ~ ifelse(. == "<1", 0, .))) %>%
  mutate(across(c("Mark Ruffalo":"Aaron Eckhart"), ~ as.numeric(.))) %>%
  pivot_longer(cols = c("Mark Ruffalo":"Aaron Eckhart")) %>%
  mutate(Month = ym(Month))

trends %>%
  group_by(name) %>%
  group_split() %>%
  purrr::walk(function(df) {
    p <<- add_trace(p,
                    data = df,
                    x = ~Month,
                    y = ~value,
                    name = unique(df$name),
                    text = ~paste(name, value),
                    hoverinfo = "text",
                    visible = "legendonly")
  })

p %>%
  layout(
    title = "Monthly Search Interest for Selected Actors since 2004",
    xaxis = list(title = "Month", range = c("2004-01-01",
                                            "2025-03-01")),
    yaxis = list(title = "Google Trend Search Interest", range = c(0, 100)),
    legend = list(title = list(text = "Select an Actor"))
  )


# joining 
joined <- trends %>% 
  mutate(name = tolower(name)) %>%
  left_join(actors, by = c("name")) 
 
# by winner
joined %>% 
  filter(!is.na(type)) %>%
  group_by(Month, type) %>% summarise(value = mean(value)) %>%
  ggplot(aes(x = Month, y = value)) +
  geom_line() +
  labs(title = "Google Trendlines for all Oscar Nominated Actors",
       subtitle = "Nominated 2004-Present") +
  facet_wrap(vars(type))
# This is pretty interesting - suggests that generally Oscar nominated actors are have searched more but it has leveled off (could reflect trends in Google Search overall). The cyclical pattern is also interesting and I'm guessing it coincides with the ceremony and nomination announcements!

joined %>% mutate(month = month(Month)) %>%
  filter(!is.na(type)) %>%
  group_by(type, month) %>%
  summarise(mean_value = mean(value)) %>%
  ungroup(month) %>%
  slice_max(order_by = mean_value, n = 3)

```

```{r}
wide <- trends %>%
  pivot_wider(names_from = Month, values_from = value) %>%
  tibble::column_to_rownames("name")
ts_matrix <- as.matrix(wide)

clusters <- tsclust(ts_matrix,
                    type = "partitional",
                    k = 5,  # tune this
                    distance = "sbd",
                    centroid = "shape",  # required with SBD
                    control = partitional_control(iter.max = 50),
                    seed = 90210)

cluster_assignments <- clusters@cluster  # cluster labels for each series
distances <- clusters@cldist

# Create a data frame with rownames and cluster assignment
cluster_df <- data.frame(
  name = rownames(ts_matrix),
  cluster = cluster_assignments,
  distance = distances
)

actor_with_cluster <- left_join(trends, cluster_df, by = "name")

actor_with_cluster %>%
  group_by(Month, cluster) %>% summarise(value = mean(value)) %>%
  ggplot(aes(x = Month, y = value, colour = factor(cluster))) +
  geom_line(show.legend = FALSE) +
  scale_y_continuous(labels = scales::comma) +
  facet_wrap(vars(cluster)) +  # Separate plots for each cluster
  scale_color_solarized() +
  theme_minimal() +
  labs(title = "Time Series Clustering", colour = "Cluster")

centroid_matrix <- do.call(rbind, clusters@centroids)

# Create a data frame from the matrix
centroid_df <- data.frame(Time = rep(1:ncol(centroid_matrix), nrow(centroid_matrix)),
                          Cluster = rep(1:nrow(centroid_matrix), each = ncol(centroid_matrix)),
                          Value = as.vector(centroid_matrix))


ggplot(centroid_df, aes(x = Time, y = Value, color = factor(Cluster))) +
  geom_line(size = 1) +
  facet_wrap(~ Cluster, ncol = 1) +
  labs(title = "Cluster Centroids", x = "Time", y = "Value", color = "Cluster") +
  theme_minimal()

actor_with_cluster %>% distinct(name, cluster, distance) %>%
  group_by(cluster) %>%
  slice_min(order_by = distance, n = 5)

actor_with_cluster %>% distinct(name, cluster) %>%
  mutate(name = tolower(name)) %>%
  left_join(actors) %>%
  filter(!is.na(cluster)) %>%
  group_by(cluster) %>% mutate(total = n()) %>%
  group_by(cluster, nominee) %>%
  summarise(prop_nominees = n()/total) %>%
  filter(nominee == 1) %>% distinct()

```

```{r}
years_seq <- 2004:2024

cluster_df <- cluster_df %>%
  distinct(name, cluster) %>%
  mutate(name = tolower(name))

features <- actors %>% 
  left_join(cluster_df, by = ("name")) %>% 
  select(name, age, gender, american, cluster)

winners <- actors %>%
  mutate(year_winner = str_remove_all(year_winner, "\\[|\\]")) %>%
  separate_rows(year_winner, sep = ",\\s*") %>%             
  mutate(year_winner = as.integer(year_winner)) %>%
  select(name, winner, year_winner)

# Cross join name and years_seq
winners_filled <- winners %>%
  # Create a data frame of all names and years
  distinct(name) %>%
  expand(name, year_winner = years_seq) %>%
  left_join(winners, by = c("name", "year_winner")) %>%
  rename(year = year_winner) %>%
  group_by(name) %>%
  mutate(
    won = ifelse(is.na(winner), "no", winner)
  ) %>%
  ungroup() %>%
  group_by(name) %>%
  mutate(
    won_previously = ifelse(lag(won != "no", default = FALSE), TRUE, FALSE)) %>%
  ungroup() %>%
  mutate(
    won_previously = ifelse(won_previously == TRUE, 1, 0)
  ) %>%
  group_by(name) %>%
  # Fill the 'nominated_previously' column down for each name
  mutate(won_previously = cummax(won_previously)) %>% 
  ungroup() %>%
  select(-won)

nominees <- actors %>%
  mutate(nominated_years = str_remove_all(nominated_years, "\\[|\\]")) %>%
  separate_rows(nominated_years, sep = ",\\s*") %>%             
  mutate(nominated_years = as.integer(nominated_years)) %>%
  select(name, nominated_years) %>%
  mutate(nominee = ifelse(!is.na(nominated_years), "yes", "no"))

nominees_filled <- nominees %>%
  # Create a data frame of all names and years
  distinct(name) %>%
  expand(name, nominated_years = years_seq) %>%
  left_join(nominees, by = c("name", "nominated_years")) %>%
  rename(year = nominated_years) %>%
  group_by(name) %>%
  mutate(
    nominated = ifelse(is.na(nominee), "no", nominee)  # Ensure no NAs in 'nominated' column
  ) %>%
  ungroup() %>%
  group_by(name) %>%
  mutate(
    nominated_previously = ifelse(lag(nominated == "yes", default = FALSE), TRUE, FALSE)
  ) %>%
  ungroup() %>%
  mutate(
    nominated_previously = as.integer(nominated_previously)
  ) %>%
  group_by(name) %>%
  # Fill the 'nominated_previously' column down for each name
  mutate(nominated_previously = cummax(nominated_previously)) %>% 
  ungroup() %>%
  select(-nominated)

winners_filled <- winners_filled %>%
  left_join(features, by = "name") %>%
  mutate(age = year - age)
prev_win <- winners_filled %>%
  select(name, year, won_previously)
nominees_filled <- nominees_filled %>%
  left_join(features, by = "name") %>%
  left_join(prev_win, by = c("name", "year")) %>%
  mutate(age = year - age)


trend_ts_data_all <- trends %>%
  mutate(year = year(Month),
         name = tolower(name)) %>%
  group_by(name, year) %>%
  arrange(Month) %>%
  summarise(
    ts_data = list(ts(value, frequency = 12)),
    var = var(value, na.rm = TRUE),
    .groups = "drop"
  )

zero_variance_log <- trend_ts_data_all %>%
  filter(is.na(var) | var == 0)

trend_ts_data <- trend_ts_data_all %>%
  filter(!is.na(var) & var > 0) %>%
  select(-var) %>%
  filter(year != 2025)

# feature extraction + custom max spike height
trend_features_ts <- trend_ts_data %>%
  mutate(
    features = map(ts_data, ~ tsfeatures(.x)),  
    max_spike_height = map_dbl(ts_data, ~ max(.x, na.rm = TRUE))
  ) %>%
  unnest(features)


model_data <- trend_features_ts %>%
  left_join(nominees_filled, by = c("name", "year")) %>%
  mutate(
    nominee = factor(ifelse(is.na(nominee), 0, 1))  
  ) %>%
  select(-frequency, -nperiods, -seasonal_period, -diff2_acf10, -seas_acf1)

set.seed(90210)
data_split <- initial_split(model_data, prop = 0.8, strata = nominee)
train_data <- training(data_split)
test_data <- testing(data_split)

train_data <- train_data %>% select(-name, -ts_data, -year)
train_data_clean <- na.omit(train_data)

## undersampling

# Split the data into the two classes
non_nominee <- train_data_clean %>% filter(nominee == 0)
nominee <- train_data_clean %>% filter(nominee == 1)

# randomly sample from the majority class (non-nominee) to match the minority class (nominee)
# randomly sample the majority class (non-nominee) to match the minority class (nominee)

# get the same proportion of non-nominee as nominee
if (nrow(non_nominee) >= nrow(nominee)) {
  non_nominee_undersampled <- non_nominee[sample(nrow(non_nominee), nrow(nominee)), ]
  
  # combine
  balanced_data <- bind_rows(non_nominee_undersampled, nominee)
  
  # shuffle rows
  balanced_data <- balanced_data %>% sample_frac(1)
  
  # confirm
  table(balanced_data$nominee)
} else {
  stop("Not enough non-nominee rows to sample from.")
}


# combine the undersampled non-nominee with the full nominee class
balanced_data <- bind_rows(non_nominee_undersampled, nominee)

# check the new balance of classes
table(balanced_data$nominee)
balanced_data$cluster <- as.factor(balanced_data$cluster)
balanced_data$gender <- as.factor(balanced_data$gender)
balanced_data$american <- as.factor(balanced_data$american)
balanced_data$won_previously <- as.factor(balanced_data$won_previously)
balanced_data$nominated_previously <- as.factor(balanced_data$nominated_previously)

balanced_data_1 <- balanced_data
balanced_data_2 <- balanced_data %>% select(-age, -gender, -american, -nominated_previously, -won_previously)

set.seed(90210)

# modeling all predictors 
data_split <- initial_split(balanced_data, prop = 0.8, strata = nominee)
train_data <- training(data_split)
test_data <- testing(data_split)

rf_model <- randomForest(nominee ~ ., data = train_data)

# model summary
print(rf_model)

predictions <- predict(rf_model, newdata = test_data)

# confusion Matrix
conf_matrix <- table(Predicted = predictions, Actual = test_data$nominee)

print(conf_matrix)

# cccuracy
accuracy <- sum(predictions == test_data$nominee) / nrow(test_data)
print(paste("Accuracy: ", accuracy))

conf_matrix_caret <- confusionMatrix(predictions, test_data$nominee)

# evaluation metrics
print(conf_matrix_caret)

importance(rf_model)
varImpPlot(rf_model)

# modeling just time series predictors
data_split <- initial_split(balanced_data_2, prop = 0.8, strata = nominee)
train_data <- training(data_split)
test_data <- testing(data_split)

rf_model <- randomForest(nominee ~ ., data = train_data)

# model summary
print(rf_model)

predictions <- predict(rf_model, newdata = test_data)

# confusion Matrix
conf_matrix <- table(Predicted = predictions, Actual = test_data$nominee)

print(conf_matrix)

# accuracy
accuracy <- sum(predictions == test_data$nominee) / nrow(test_data)
print(paste("Accuracy: ", accuracy))

conf_matrix_caret <- confusionMatrix(predictions, test_data$nominee)

# evaluation metrics
print(conf_matrix_caret)

importance(rf_model)
varImpPlot(rf_model)

```


